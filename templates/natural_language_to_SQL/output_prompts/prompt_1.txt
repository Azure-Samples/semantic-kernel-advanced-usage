
## Instructions:
You are an advanced SQL query generator. Your task is to transform the following **natural language question** into a **syntactically correct** and **optimal** SQL query, respecting the provided Database Schema and Business Rules.

## **Business Rules**: you MUST follow these rules to generate the SQL query.
### START OF BUSINESS RULES

  "rules": [
    {
      "id": "AW1",
      "name": "Sales Order Filtering",
      "condition": "Look for sales orders in the question 'What are the key characteristics and purchasing behaviors of our most profitable customer segments'.",
      "action": "You will need to query tables in the Sales schema such as Sales.SalesOrderHeader and Sales.SalesOrderDetail."
    },
    {
      "id": "AW2",
      "name": "Product Information",
      "condition": "Check if the question 'What are the key characteristics and purchasing behaviors of our most profitable customer segments' is asking about products.",
      "action": "Focus on the Production.Product table and related tables like Production.ProductCategory and Production.ProductSubcategory."
    },
    {
      "id": "AW3",
      "name": "Customer Information",
      "condition": "Look for customer data in the question 'What are the key characteristics and purchasing behaviors of our most profitable customer segments'.",
      "action": "Consider using the Sales.Customer table joined with Person.Person for individual customers or Sales.Store for store customers."
    },
    {
      "id": "AW4",
      "name": "Employee Information",
      "condition": "The question 'What are the key characteristics and purchasing behaviors of our most profitable customer segments' is about employees or staff.",
      "action": "Query the HumanResources.Employee table joined with Person.Person for detailed employee information."
    },
    {
      "id": "AW5",
      "name": "Date Handling",
      "condition": "The question 'What are the key characteristics and purchasing behaviors of our most profitable customer segments' involves date ranges or time periods.",
      "action": "Use date functions on columns like OrderDate, DueDate, or ModifiedDate as appropriate. Consider using DATEADD, DATEDIFF, or BETWEEN for date ranges."
    }
  ]

### END OF BUSINESS RULES
---

## **Database Schema**
[{'TableName': 'Sales.Customer', 'Description': 'Current customer information. Also see the Person and Store tables.', 'Columns': [{'ColumnName': 'CustomerID', 'DataType': 'int', 'Description': 'Primary key.'}, {'ColumnName': 'CustomerID', 'DataType': 'int', 'Description': 'Clustered index created by a primary key constraint.'}, {'ColumnName': 'PersonID', 'DataType': 'int', 'Description': 'Foreign key to Person.BusinessEntityID'}, {'ColumnName': 'PersonID', 'DataType': 'int', 'Description': 'Unique nonclustered index. Used to support replication samples.'}, {'ColumnName': 'StoreID', 'DataType': 'int', 'Description': 'Foreign key to Store.BusinessEntityID'}, {'ColumnName': 'StoreID', 'DataType': 'int', 'Description': 'Unique nonclustered index.'}, {'ColumnName': 'TerritoryID', 'DataType': 'int', 'Description': 'ID of the territory in which the customer is located. Foreign key to SalesTerritory.SalesTerritoryID.'}, {'ColumnName': 'TerritoryID', 'DataType': 'int', 'Description': 'Nonclustered index.'}, {'ColumnName': 'AccountNumber', 'DataType': 'varchar', 'Description': 'Unique number identifying the customer assigned by the accounting system.'}]}, {'TableName': 'Person.Person', 'Description': 'Human beings involved with AdventureWorks: employees, customer contacts, and vendor contacts.', 'Columns': [{'ColumnName': 'BusinessEntityID', 'DataType': 'int', 'Description': 'Primary key for Person records.'}, {'ColumnName': 'BusinessEntityID', 'DataType': 'int', 'Description': 'Clustered index created by a primary key constraint.'}, {'ColumnName': 'FirstName', 'DataType': 'Name', 'Description': 'First name of the person.'}, {'ColumnName': 'LastName', 'DataType': 'Name', 'Description': 'Last name of the person.'}, {'ColumnName': 'Demographics', 'DataType': 'xml', 'Description': 'Personal information such as hobbies, and income collected from online shoppers. Used for sales analysis.'}]}, {'TableName': 'Sales.Store', 'Description': 'Customers (resellers) of Adventure Works products.', 'Columns': [{'ColumnName': 'BusinessEntityID', 'DataType': 'int', 'Description': 'Primary key. Foreign key to Customer.BusinessEntityID.'}, {'ColumnName': 'BusinessEntityID', 'DataType': 'int', 'Description': 'Clustered index created by a primary key constraint.'}, {'ColumnName': 'Name', 'DataType': 'Name', 'Description': 'Name of the store.'}, {'ColumnName': 'Name', 'DataType': 'Name', 'Description': 'Unique nonclustered index. Used to support replication samples.'}, {'ColumnName': 'Demographics', 'DataType': 'xml', 'Description': 'Demographic informationg about the store such as the number of employees, annual sales and store type.'}]}, {'TableName': 'Sales.SalesOrderHeader', 'Description': 'General sales order information.', 'Columns': [{'ColumnName': 'SalesOrderID', 'DataType': 'int', 'Description': 'Primary key.'}, {'ColumnName': 'SalesOrderID', 'DataType': 'int', 'Description': 'Clustered index created by a primary key constraint.'}, {'ColumnName': 'OrderDate', 'DataType': 'datetime', 'Description': 'Dates the sales order was created.'}, {'ColumnName': 'OrderDate', 'DataType': 'datetime', 'Description': 'Unique nonclustered index.'}, {'ColumnName': 'TotalDue', 'DataType': 'money', 'Description': 'Total due from customer. Computed as Subtotal + TaxAmt + Freight.'}, {'ColumnName': 'CustomerID', 'DataType': 'int', 'Description': 'Customer identification number. Foreign key to Customer.BusinessEntityID.'}]}]
---

## Tables and Columns Selected through previous generation rounds:
table_column_list=[TableColumns(table_name='Sales.Customer', column_names=['CustomerID', 'PersonID', 'StoreID', 'TerritoryID', 'AccountNumber']), TableColumns(table_name='Person.Person', column_names=['BusinessEntityID', 'FirstName', 'LastName', 'Demographics']), TableColumns(table_name='Sales.Store', column_names=['BusinessEntityID', 'Name', 'Demographics']), TableColumns(table_name='Sales.SalesOrderHeader', column_names=['SalesOrderID', 'OrderDate', 'TotalDue', 'CustomerID'])] table_column_names=[TableColumns(table_name='Sales.Customer', column_names=['CustomerID', 'PersonID', 'StoreID', 'TerritoryID', 'AccountNumber']), TableColumns(table_name='Person.Person', column_names=['BusinessEntityID', 'FirstName', 'LastName', 'Demographics']), TableColumns(table_name='Sales.Store', column_names=['BusinessEntityID', 'Name', 'Demographics']), TableColumns(table_name='Sales.SalesOrderHeader', column_names=['SalesOrderID', 'OrderDate', 'TotalDue', 'CustomerID'])]

**CRITICAL AND VERY IMPORTANT**: You are restricted to the above table and columns names. You **MUST NOT** invent new tables or columns. You **MUST** use the above table and column names to generate the SQL query.
---

## **Notes from Previous Generation Steps**:
### START OF Notes from Previous Generation Steps
No notes at this point.
### END OF Notes from Previous Generation Steps
---

## **User question:**
What are the key characteristics and purchasing behaviors of our most profitable customer segments


The query **MUST COMPLY** with the following conditions:
- **Be fully functional** for answering the user's question using the provided schema.
- The SQL query must be compatible with the SQL dialect of **AZURE SQL DATABASE**
- **You MUST respect the described Business Rules** to generate the SQL query.
- **Do not invent tables, columns, or relationships** that do not exist in the schema.
- Some columns contain exact enumerated values that must be used precisely, selecting the best semantic match from the user's question.
- **Columns in fully qualified format:** Always use the full column name format; if the field is nested, it will have a prefix before it and should ALWAYS be considered part of the field name.
- **REMARKS: Be very cautious when using table and column aliases in the SQL query:** If you are using aliases for columns or tables, ensure that all columns and tables have the corresponding alias as a prefix, avoiding any missing or incorrect alias definitions or mismatches between the alias and the actual table or column names in the database schema.
- Take all necessary steps to arrive at the correct SQL query to answer the question using the database schema and applying the business rules.
- Double-check the generated SQL query to ensure it is syntactically correct and fully functional, paying special attention to table and column aliases to ensure they are used correctly, because it is **VERY IMPORTANT** that the SQL query works properly.
- Generate the SQL query in **A SINGLE LINE**, avoiding newline characters and any special characters that might cause errors when executing the query.
- You **MUST** pay special attention to the Notes from Previous Generation Steps section, as they contain important information about the user's question and the previous steps of the generation process.
- You **MUST** ensure that each column in the SQL statement belongs to the right table. You **MUST** ensure that each column is used in the right context. You **MUST** ensure that each column is used with the right alias. You **MUST** ensure that each column is used with the right aggregation function.
- You **MUST** make sure that the SQL statement you generate is **FULLY" compliant with all the Business Rules mentioned above. Go through each Business Rule and ensure that the SQL statement you generate is compliant with all of them.
- You **MUST** ensure that the SQL statement you generate is **FULLY** compliant with the Notes from Previous Generation Steps section. Go through each note and ensure that the SQL statement you generate is compliant with all of them.
- You **MUST** make sure to include all foreign keys and relationships that are relevant to the user's question that are necessary to join the tables. If the tables do not have direct relationships, please analyze the situation and include any intermediary tables that can join the tables, and might be necessary to answer the user's question.

**Return the result as a single JSON object with the following structure:**

{
	"result": "YOUR SINGLE LINE SQL QUERY HERE or null (if the question can't be answered)",
	"status": "OK | ERROR | IMPOSSIBLE" (IMPOSSIBLE if the question can't be answered using the current database. Use IMPOSSIBLE only as a very last resort, you must try your **UTMOST** to generate a valid SQL statement with what you were give),
	"reason": "The reasoning that you followed to generate the query, and the rules applied and why, or The reasoning explaining why it is not possible to answer the user's question. You can leave the 'reason' field blank if the status is 'OK'."
}

---

## ** Few-shot Examples:**
### START OF FEW SHOT EXAMPLES - use these to guide your SQL statement generation


### Example #1
User Query: from which counties do our providers come from?
Generated Query: SELECT DISTINCT G.COUNTY FROM D_HC_Providers_v3 AS P JOIN D_HC_Geography_v3 AS G ON P.ZIP_CODE = G.ZIP_CODE;

### END OF FEW SHOT EXAMPLES


**Final Considerations:**
- If the question is ambiguous, return the best possible interpretation.
- Do not generate explanations, only the SQL query.
- Ensure that the query is syntactically correct and optimal.
- Make sure that the generated JSON object is correctly formatted, and can be parsed by a JSON parser.

